# Pact Contract Testing

This project includes comprehensive Pact contract testing between the consumer (console app) and provider (Lambda function).

## Overview

**Pact** is a contract testing framework that ensures the consumer's expectations match what the provider actually delivers. It works by:

1. **Consumer tests** generate a "pact" (contract) file containing the expected requests and responses
2. **Provider tests** verify that the actual provider can fulfill the contract

## Architecture

```
┌─────────────────────┐         ┌─────────────────────┐
│   Consumer Tests    │  Pact   │   Provider Tests    │
│   (Console App)     │ ------> │   (Lambda Function) │
│                     │ Contract│                     │
└─────────────────────┘         └─────────────────────┘
```

## Files

### Consumer Side (consumer/)
- `ApiGatewayLambdaPactTests.cs` - Consumer contract tests
- `pacts/ApiConsumer-ApiGatewayLambda.json` - Generated contract file

### Provider Side (lambda/)
- `ApiGatewayLambdaProviderTests.cs` - Provider verification tests

### Scripts
- `run-pact-tests.ps1` - PowerShell script to run all tests
- `run-pact-tests.sh` - Bash script to run all tests

## Test Scenarios

The Pact tests cover all the main scenarios:

### 1. Valid Request Test
- **Input**: `{"FirstName": "John", "LastName": "Doe"}`
- **Expected**: `200 OK` with success message and full name

### 2. Missing FirstName Test
- **Input**: `{"LastName": "Doe"}`
- **Expected**: `400 Bad Request` with error message

### 3. Missing LastName Test
- **Input**: `{"FirstName": "John"}`
- **Expected**: `400 Bad Request` with error message

### 4. Invalid HTTP Method Test
- **Input**: `GET /` (instead of POST)
- **Expected**: `405 Method Not Allowed` with error message

## Running the Tests

### Option 1: Run All Tests (Recommended)

**PowerShell:**
```powershell
.\run-pact-tests.ps1
```

**Bash:**
```bash
chmod +x run-pact-tests.sh
./run-pact-tests.sh
```

### Option 2: Run Tests Individually

**Step 1: Generate Consumer Contract**
```bash
cd consumer
dotnet test ApiGatewayLambdaPactTests.cs
```

**Step 2: Verify Provider Contract**
```bash
cd ../lambda
dotnet test ApiGatewayLambdaProviderTests.cs
```

## Expected Output

### Consumer Tests
```
✅ Consumer tests passed - Pact files generated
✅ Pact contract file generated successfully
📄 Contract file: consumer/pacts/ApiConsumer-ApiGatewayLambda.json
```

### Provider Tests
```
✅ Provider tests passed - Contract verified
🎉 All Pact tests completed successfully!
```

## Contract File

The generated contract file (`consumer/pacts/ApiConsumer-ApiGatewayLambda.json`) contains:

```json
{
  "consumer": {
    "name": "ApiConsumer"
  },
  "provider": {
    "name": "ApiGatewayLambda"
  },
  "interactions": [
    {
      "description": "A valid request with firstname and lastname",
      "request": {
        "method": "POST",
        "path": "/",
        "headers": {
          "Content-Type": "application/json"
        },
        "body": {
          "FirstName": "John",
          "LastName": "Doe"
        }
      },
      "response": {
        "status": 200,
        "headers": {
          "Content-Type": "application/json"
        },
        "body": {
          "message": "Request processed successfully",
          "fullName": "John Doe"
        }
      }
    }
    // ... more interactions
  ]
}
```

## Benefits

1. **Contract Validation**: Ensures the API contract is honored by both sides
2. **Early Detection**: Catches breaking changes before deployment
3. **Documentation**: The contract serves as living documentation
4. **Independent Testing**: Consumer and provider can be tested independently
5. **Confidence**: Provides confidence that integration will work

## How It Works

### Consumer Tests
1. Use `PactBuilder` to define expected interactions
2. Mock server is created based on the contract
3. Consumer code is tested against the mock
4. Contract file is generated

### Provider Tests
1. Read the contract file generated by consumer tests
2. Start a test server that wraps the Lambda function
3. Pact verifier sends requests from the contract to the test server
4. Responses are validated against the contract expectations

## Test Server

The provider tests use a custom `TestServer` class that:
- Wraps the Lambda function in an HTTP listener
- Converts HTTP requests to API Gateway events
- Calls the Lambda function
- Converts Lambda responses back to HTTP responses

This allows the Lambda function to be tested as if it were a regular web API.

## Troubleshooting

### Common Issues

1. **Contract file not found**: Make sure consumer tests run first
2. **Port conflicts**: The test server uses port 9223
3. **Path issues**: Ensure the contract file path is correct in provider tests

### Debug Tips

- Use `--logger:"console;verbosity=detailed"` for detailed test output
- Check the generated contract file to verify expectations
- Ensure both consumer and provider use the same JSON serialization settings

## Integration with CI/CD

These tests can be integrated into your CI/CD pipeline:

1. **Consumer Pipeline**: Run consumer tests and publish contract to Pact Broker
2. **Provider Pipeline**: Run provider tests against the published contract
3. **Deployment**: Only deploy if all contracts are verified

## Dependencies

- **PactNet**: Pact implementation for .NET
- **xUnit**: Testing framework
- **System.Text.Json**: JSON serialization (consistent with Lambda function)

## Best Practices

1. **Version Contracts**: Use semantic versioning for contract changes
2. **Backward Compatibility**: Ensure provider can handle older contract versions
3. **Meaningful Descriptions**: Use clear descriptions for each interaction
4. **Real Data**: Use realistic test data that reflects actual usage
5. **Regular Testing**: Run contract tests as part of your regular test suite
